#!/usr/bin/env python2
#
# Script to help manage credentials in gnome-keyring.

from functools import wraps
import getpass
import gnomekeyring
import hashlib
import hmac
from itertools import izip, starmap
from operator import xor
import optparse
import os
import re
import time
from struct import Struct
import sys

class Formatter(optparse.IndentedHelpFormatter):
  def format_description(self, description):
    return description

class Keyring(object):
  def __init__(self, keyring='login'):
    self.keyring = keyring

  def keys(self):
    keys = []
    for item in gnomekeyring.list_item_ids_sync(self.keyring):
      info = gnomekeyring.item_get_info_sync(self.keyring, item)
      keys.append(info.get_display_name())
    return keys

  def get(self, key, smtp=False, hash_=None, salt=False, pbkdf2=False):
    attrs = {'key': key}
    if smtp:
      user, server = key.rsplit('@', 1)
      attrs = {'user': user, 'server': server, 'protocol': 'smtp'}

    items = gnomekeyring.find_items_sync(
      gnomekeyring.ITEM_NETWORK_PASSWORD, attrs
    )
    secret = items[0].secret
    if pbkdf2:
      secret = pbkdf2_hex(
        secret,
        key if salt else '',
        hashfunc=getattr(hashlib, hash_) if hash_ else None,
      )
    elif hash_ is not None:
      if salt:
        secret = '%s{%s}' % (secret, key)

      if hash_ in ('b64', 'base64'):
        secret = secret.encode('base64').strip('\n').strip('=')
      else:
        method = getattr(hashlib, hash_)()
        method.update(secret)
        secret = method.hexdigest()

    return secret

  def set(self, key, value, smtp=False):
    attrs = {'key': key}
    if smtp:
      user, server = key.rsplit('@', 1)
      attrs = {'user': user, 'server': server, 'protocol': 'smtp'}

    gnomekeyring.item_create_sync(
      self.keyring, gnomekeyring.ITEM_NETWORK_PASSWORD,
      key, attrs, value, True
    )

  def delete(self, key):
    items = gnomekeyring.find_items_sync(
      gnomekeyring.ITEM_NETWORK_PASSWORD, {'key': key}
    )
    if items:
      gnomekeyring.item_delete_sync(self.keyring, items[0].item_id)

  def find(self, pattern):
    if isinstance(pattern, basestring):
      pattern = re.compile(pattern)

    results = []
    for item in gnomekeyring.list_item_ids_sync(self.keyring):
      info = gnomekeyring.item_get_info_sync(self.keyring, item)
      name = info.get_display_name()
      if pattern.search(name):
        results.append(name)

    return results

# pbkdf2 taken from https://github.com/mitsuhiko/python-pbkdf2
# Copied inline to
# a) alleviate the need to install an external library
# b) guard against the implementation changing resulting in different output,
#    rendering uses of the previous output invalid.
_pack_int = Struct('>I').pack

def pbkdf2_hex(data, salt, iterations=1000, keylen=32, hashfunc=None):
  """Like :func:`pbkdf2_bin` but returns a hex encoded string."""
  return pbkdf2_bin(data, salt, iterations, keylen, hashfunc).encode('hex')

def pbkdf2_bin(data, salt, iterations=1000, keylen=32, hashfunc=None):
  """Returns a binary digest for the PBKDF2 hash algorithm of `data`
  with the given `salt`.  It iterates `iterations` time and produces a
  key of `keylen` bytes.  By default SHA-1 is used as hash function,
  a different hashlib `hashfunc` can be provided.
  """
  hashfunc = hashfunc or hashlib.sha1
  mac = hmac.new(data, None, hashfunc)
  def _pseudorandom(x, mac=mac):
    h = mac.copy()
    h.update(x)
    return map(ord, h.digest())
  buf = []
  for block in xrange(1, -(-keylen // mac.digest_size) + 1):
    rv = u = _pseudorandom(salt + _pack_int(block))
    for i in xrange(iterations - 1):
      u = _pseudorandom(''.join(map(chr, u)))
      rv = starmap(xor, izip(rv, u))
    buf.extend(rv)
  return ''.join(map(chr, buf))[:keylen]

def output(func):
    def wrapper(options, *args, **kwargs):
      result = None
      try:
        result = func(options, *args, **kwargs)

        if options.tempfile:
          _tempfile(options.tempfile, result)

        if options.clipboard:
          _clipboard(result)

        if not options.tempfile and not options.clipboard:
          print(result)
      finally:
        if not result:
          if options.clipboard:
            _clipboard('')

    return wraps(func)(wrapper)

def main():
  parser = optparse.OptionParser()
  parser.add_option(
    "-k", "--keyring", dest="keyring", default="login",
    help="the keyring to use (default: login)")
  parser.add_option(
    "--hash", dest="hash",
    help="run the password through the specified hash before outputting it")
  parser.add_option(
    "--salt", action="store_true", dest="salt",
    help="combined with --hash, the key will be used as a salt")
  parser.add_option(
    "--pbkdf2", action="store_true", dest="pbkdf2",
    help="use pbkdf2 with optional --hash and --salt to hash the password for output")
  parser.add_option(
    "-t", "--tempfile", dest="tempfile",
    help="write get/password/username to a tempfile (deleted 1s after creation)")
  parser.add_option(
    "-c", "--clipboard", action="store_true", dest="clipboard",
    help="write get/password/username to a clipboard (cleared 10s after being set)")

  parser.set_usage('Usage: keyring [options] <command> [command args]')
  parser.set_description(
    'Commands:\n'
    '  list - list all stored keys\n'
    '  set [<key>] - set a key\n'
    '  get/password <key> - get the password for the given key\n'
    '  delete <key> - delete the entry for the given key\n'
    '  username <domain> - get the username for the given domain\n'
    '  smtp [<key>] - set a smtp password (msmtp format)\n'
  )
  parser.formatter = Formatter()

  (options, args) = parser.parse_args()

  if not len(args):
    parser.print_help()
    sys.exit(1)

  valid_args = {
    'list': 1,
    'set': lambda a: 1 <= a <= 2,
    'smtp': lambda a: 1 <= a <= 2,
    'delete': 2,
    'username': lambda a: a >= 2,
    'password': lambda a: a >= 2,
    'get': lambda a: a >= 2,
  }
  valid = valid_args.get(args[0])
  if not callable(valid):
    num = valid
    valid = lambda a: a == num
  if not valid(len(args)):
    parser.print_help()
    sys.exit(1)

  command = args[0]

  keyring = Keyring(options.keyring)

  if command == 'list':
    for name in sorted(keyring.keys()):
      print(name)

  elif command == 'get' or command == 'password':
    try:
      _get_password(options, keyring, *args[1:])
    except gnomekeyring.NoMatchError:
      sys.stderr.write('error: No match found.\n')
      sys.exit(1)

  elif command == 'set':
    key = args[1] if len(args) > 1 else _get_input('key: ')
    password = _get_input('password: ', password=True)
    print('')
    keyring.set(key, password)

  elif command == 'delete':
    try:
      keyring.delete(args[1])
    except gnomekeyring.NoMatchError:
      sys.stderr.write('error: No match found.\n')
      sys.exit(1)

  elif command == 'username':
    _get_username(options, keyring, *args[1:])

  elif command == 'smtp':
    user = args[1] if len(args) > 1 else _get_input('user (user@example.com): ')
    server = _get_input('server (smtp.example.com): ')
    password = _get_input('password: ', password=True)
    print('')
    key = '%s@%s' % (user, server)
    keyring.set(key, password, smtp=True)

@output
def _get_password(options, keyring, *keys):
  error = None
  for key in keys:
    try:
      return keyring.get(
        key, hash_=options.hash, salt=options.salt, pbkdf2=options.pbkdf2)
    except gnomekeyring.NoMatchError as nme:
      error = nme

  if error:
    raise error

@output
def _get_username(options, keyring, *keys):
  for key in keys:
    results = keyring.find('.*@%s$' % key)
    if results:
      results = set([r.rsplit('@', 1)[0] for r in results])
    else:
      results = keyring.find('^%s$' % key)

    if results:
      return '\n'.join(results)

  out('error: No match found.', file=sys.stderr)

def _get_input(prompt, password=False):
  if password:
    value = getpass.getpass(prompt)
  else:
    value = raw_input(prompt)

  if not value:
    sys.stderr.write('No value supplied, aborting.')
    sys.exit(0)

  return value

def _tempfile(tempfile, content):
  with open(tempfile, 'w') as temp:
    temp.write(content)
  _cleanup(_cleanup_tempfile, 1, tempfile)

def _cleanup_tempfile(timeout, tempfile):
  time.sleep(timeout)
  os.unlink(tempfile)

def _clipboard(content):
  os.popen('xclip -selection clipboard', 'wb').write(content)
  if content:
    _cleanup(_cleanup_clipboard, 10)

def _cleanup_clipboard(timeout):
  time.sleep(timeout)
  os.popen('xclip -selection clipboard', 'wb').write('')

def _cleanup(func, *args):
  try:
    pid = os.fork()
    if pid > 0:
      sys.exit(0)
  except OSError as e:
    out('Failed to fork cleanup: %s' % e, file=sys.stderr)
    sys.exit(1)

  # decouple from parent
  os.chdir('/')
  os.setsid()
  os.umask(0)

  try:
    pid = os.fork()
    if pid > 0:
      out('Cleanup fork pid: %s' % pid, file=sys.stderr)
      sys.exit(0)
  except OSError as e:
    out('Failed to fork cleanup: %s' % e, file=sys.stderr)
    sys.exit(1)

  func(*args)

def out(string, **kwargs):
  file = kwargs.pop('file', sys.stdout)
  file.write('%s\n' % string)

if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print('')
